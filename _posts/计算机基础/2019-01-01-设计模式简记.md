---
title: 设计模式简记
toc: true
permalink: /posts/computer/simple-dp.html
categories: 软件理论
date: 2019-01-01
---

本文从结构和语义方面对比并总结了Java的23个设计模式。

## 概述

### 什么是设计模式

设计模式是某些特定问题的解决方案，理解设计模式要把握如下几点：

- 特定问题：设计模式不是万能的，某个设计模式只能解决某个或某类问题
- 重复出现：解决重复出现的问题才有意义
- 解决方案：设计模式是一种解决方案
- 经过验证：设计模式经过了广泛的验证，得到了公认和认可

### 为什么要学设计模式

- 开发人员的标准词汇，方便和其他开发人员沟通
- 前人经验的积累，提高自己的捷径
- 通常是某类问题的最佳解决方案，避免重复发明轮子和出错

### 如何学设计模式

- 问题背景，就是这个模式是要解决什么问题
- 解决方案，就是这个模式如何解决这个问题
- 变通融合，就是遇到相似的问题，如何通过变通或者融合的方式解决

## 设计模式的分类

分类的目的是更好的理解的记忆，GoF的《设计模式：可复用面向对象软件的基础》中，依据模式的目的和范围，将设计模式分类如下：

|     | 创建型            | 结构型          | 行为型
| --- | ---------------  | -------------- | ------------------------
| 类  | Factory Method   | Adapter（类）   | Interpreter
|     |                  |                | Template Method
| 对象 | Abstract Factory | Adapter（对象） | Chain of Responsibility
|     | Builder          | Bridge         | Command
|     | Prototype        | Composite      | Iterator
|     | Singleton        | Decorator      | Mediator
|     |                  | Facade         | Memento
|     |                  | Flyweight      | Observer
|     |                  | Proxy          | State
|     |                  |                | Strategy
|     |                  |                | Visitor

目的，即模式是用来完成什么工作的。模式依据其目的可分为创建型（Creational）、结构型( Structural)、或行为型( Behavioral )三种。创建型模式与对象的创建有关；结构型模式处理类或对象的组合；行为型模式对类或对象怎样交互和怎样分配职责进行描述。

范围，指模式主要是用于类还是用于对象。类模式处理类和子类之间的关系，这些关系通过继承建立，是静态的，在编译时刻便确定下来了。对象模式处理对象间的关系，这些关系在运行时刻是可以变化的，更具动态性。从某种意义上来说，几乎所有模式都使用继承机制，所以“类模式”只指那些集中于处理类间关系的模式，而大部分模式都属于对象模式的范畴。

创建型类模式将对象的部分创建工作延迟到子类，而创建型对象模式则将它延迟到另一个对象中。结构型类模式使用继承机制来组合类，而结构型对象模式则描述了对象的组装方式。行为型类模式使用继承描述算法和控制流，而行为型对象模式则描述一组对象怎样协作完成单个对象所无法完成的任务。

## 理解设计模式

### 外观模式、解释器模式

这两个模式放在一起的原因是它们更多的是一种思想。

外观模式的思想是为一个复杂的模块或系统提供一个大多数情况适用的默认实现，这个实现封装了内部的复杂交互，使得多数情况可以通过简单的调用门面接口解决问题，只有在特殊的情况下才需要调用内部接口。

解释器模式实际上一个简单的语法分析工具，实际开发中用得比较少，需要时可使用开源的解析工具包。

### 迭代器模式、原型模式

之所以把这两个模式放在一起，是因为Java本身内置了这两个模式的实现。

迭代器模式提供了一种在不暴露容器内部细节的情况下访问容器中各个元素的方法，Java提供了Iterator接口和支持遍历容器的for来实现迭代器。

原型模式通过复制原型对象来快速创建新对象，Java中Cloneable接口和Object对象的clone方法来支持原型模式。

### 适配器模式、代理模式、装饰模式

这三个模式放在一起的原因是它们的结构非常相似，都是通过组合的方式持有另一个对象，并将操作委托给持有的对象来实现。理解这三个模式的关键在于理解它们各自的偏重点：

适配器模式更注重接口转换，适配和被适配的两个类没有任何关系，AOP就是代理模式的典型应用。

代理模式则通过增加一个代理层来实现控制对象的访问，代理和被代理的对象具有相同的接口。

装饰模式的目的是在不改变接口的情况下加强/减弱功能，装饰和被装饰的对象有相同的接口或者父类，Java中典型的使用是各种I/O流。

实际上装饰模式是代理模式的一个特殊情况。

### 策略模式

策略模式的本质是多态，通过多态实现算法的自由切换。

### 组合模式

组合模式的本质是实现一棵树，并统一组合节点和叶子节点的访问，简化高层模块的调用。

### 观察者模式

观察者模式的本质是注册监听（或者说发布订阅）机制。

### 职责链模式

职责链模式通过一条链来解耦请求的发送者和接受者，链上每个对象都有机会处理请求，Servlet中Filter应用了职责链模式。

### 单例模式

单例模式的本质是控制对象数量，实现延迟初始化。使用单例模式要注意线程安全。

### 享元模式

享元模式的思想是一种缓存或池技术，享元模式需要分离出对象中可共享的部分缓存起来，减少大量对象的创建，节省了内存。使用享元模式也要注意线程安全。

### 工厂方法模式、模版方法模式

之所以将这两个模式放在一起，是因为它们都是将一些操作延迟到子类实现的。工厂方法中的子类负责对象的实例化，而模版方法中的子类则是算法具体步骤的实现。

### 中介者模式、状态模式、命令模式

将这三个模式放在一起是因为这三个模式的本质都是封装。

中介者模式使用一个对象封装一系列对象的交互，使得其他对象之间无需直接交互，而且只需要改变中介对象就可以改变对象间的交互。

命令模式将请求封装为命令对象，而将请求的接受者作为命令对象的参数，将调用者和命令接受者解耦，并能够支持宏命令、命令队列和命令的撤销。

状态模式将状态及该状态下的操作封装起来，达到状态改变时行为改变的目的。状态模式中需要一个上下文角色负责状态的切换。

### 备忘录模式

备忘录模式的本质是对象的备份，提供了一种在不暴露对象内部细节的前提下保存和恢复状态的方法。

### 抽象工厂模式

抽象工厂模式的意识是为创建成套的（或者说相关、相互依赖）的对象提供一个接口。

### 桥接模式

桥接模式的本质是将继承关系转化成关联关系，当一个类存在两个独立变化的维度时，使用桥接模式来分离这两个维度，能降低了类与类之间的耦合，减少了类的数量。

### 生成器模式

生成器模式解决的是复杂对象的创建问题，本质是分离出整体的构建算法，使其可以复用。

### 访问者模式

访问者模式中，被访问的对象提供一个方法，该方法的参数是访问者，被访问者在这个方法中调用访问者来实现不同的功能，这就是模式中说的不改变类的前提下定义新操作，但访问者知道被访问者的内部实现。

## 类图与参与者

待补充
